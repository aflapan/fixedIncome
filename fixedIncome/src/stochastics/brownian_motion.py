"""
This script contains a class for generating multi-dimensional Brownian Motion paths with optional correlation.
"""


import matplotlib.pyplot as plt
from datetime import datetime, date, timedelta
import math
import numpy as np
from typing import Optional
from collections.abc import Callable
import pandas as pd


class BrownianMotion(Callable):
    """
    A class for multidimensional brownian motion with optional correlation.
    """
    def __init__(self, start_date_time: datetime, end_date_time: datetime, dimension: int = 1, correlation_matrix: Optional[np.ndarray] = None) -> None:

        self._start_date_time = start_date_time
        self._end_date_time = end_date_time
        self._dimension = dimension
        assert dimension, dimension == correlation_matrix.shape
        self.correlation_matrix = correlation_matrix if correlation_matrix is not None else np.eye(self._dimension)
        self.lower_triangular_mat = np.linalg.cholesky(self.correlation_matrix)
        self._path = None

    @property
    def start_date_time(self) -> datetime:
        return self._start_date_time

    @property
    def end_date_time(self) -> datetime:
        return self._end_date_time

    @property
    def dimension(self) -> int:
        return self._dimension

    @property
    def path(self):
        return self._path

    def __call__(self, datetime_obj: datetime) -> np.array:
        if self.path is None:
            raise ValueError('Brownian Motion called when path is None. '
                             'First call generate_path method with set_path variable set to True.')

        if datetime_obj < self.start_date_time or datetime_obj > self.end_date_time:
            raise ValueError(f'Provided datetime {str(datetime_obj)} is outside of'
                             f'the range {str(self.start_date_time)} to {str(self.end_date_time)}.')

        num_steps = self.path.shape[1]
        time_diff = self.end_date_time - self.start_date_time
        time_spread = time_diff.total_seconds()
        time_since_start = (datetime_obj - self.start_date_time)
        interpolated_index = math.floor((num_steps-1) * time_since_start.total_seconds() / time_spread)
        return self.path[:, interpolated_index]

    def _generate_increments(self, dt: float, num_steps: int, seed: Optional[int] = None) -> np.ndarray:
        """
        Returns a num_increments x num_steps numpy nd.array, where each row corresponds to a
        Correlated Brownian Motion increments are generated by applying the Cholesky Decomposition to the correlation matrix
        and multiplying the resulting lower-triangular matrix to the uncorrelated brownian motion increments.
        See Brigo and Mercurio's *Interest Rate Models-Theory and Practice Second Ed.*, page 31.
        """
        np.random.seed(seed=seed)
        brownian_increments = math.sqrt(dt) * np.random.standard_normal((self.dimension, num_steps))
        brownian_increments = self.lower_triangular_mat @ brownian_increments  # induce correlation
        return brownian_increments

    def generate_path(self, dt: float, set_path: bool = True, seed: Optional[int] = None) -> np.array:
        """
        Generates Brownian Motion sample paths.

        dt is a float whose scale is seconds.
        """
        time_diff = self.end_date_time - self.start_date_time
        time_diff_in_seconds = math.ceil(time_diff.total_seconds())
        num_steps = math.ceil(time_diff_in_seconds/dt)

        brownian_increments = self._generate_increments(dt, num_steps, seed=seed)
        brownian_paths = np.zeros((self.dimension, num_steps + 1))
        brownian_paths[:, 1:] = brownian_increments.cumsum(axis=1)

        if set_path:
            self._path = brownian_paths

        return brownian_paths

    def plot(self):
        plt.figure(figsize=(10, 6))
        plt.title(f'Brownian Motion Path')
        date_range = pd.date_range(start=self.start_date_time, end=self.end_date_time, periods=self.path.shape[1])
        plt.plot(date_range, self.path.T, color='darkblue', linewidth=0.5, alpha=1)
        plt.grid(alpha=0.25)
        plt.show()


#------------------------------------------------------------------------------

def main():
    rho = 0.0
    correlation_matrix = np.array([[1.0, rho], [rho, 1.0]])

    start_time = datetime(2023, 10, 15, 0, 0, 0, 0)
    end_time = datetime(2023, 10, 15, 23, 59, 59, 999_999)

    bm = BrownianMotion(start_date_time=start_time,
                        end_date_time=end_time,
                        dimension=1,
                        correlation_matrix=None)

    paths = bm.generate_path(dt=1.0, seed=1)
    bm.plot()

    print('Brownian motion call value:', bm(end_time))
    print('Last element of path:', paths[-1, -1])


if __name__ == '__main__':
    main()


