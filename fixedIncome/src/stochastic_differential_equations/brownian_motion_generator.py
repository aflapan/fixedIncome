"""
Utility tools for generating

"""
import collections.abc
from typing import Optional, Callable
import numpy as np
import math
import matplotlib.pyplot as plt
from fixedIncome.src.stochastic_differential_equations.drift_and_diffusion_functions import (DriftDiffusionPair,
                                                                                             geometric_brownian_motion,
                                                                                             vasicek_model)


def generate_brownian_increments(
        num_paths: int, num_steps: int, end_time: float, correlation_matrix: Optional[np.ndarray] = None
) -> np.ndarray:
    """
    Returns a num_increments x num_steps numpy nd.array, where each row corresponds to a
    Correlated Brownian Motion increments are generated by applying the Cholesky Decomposition to the correlation matrix
    and multiplying the resulting lower-triangular matrix to the uncorrelated brownian motion increments.
    See Brigo and Mercurio's *Interest Rate Models-Theory and Practice Second Ed.*, page 31.
    """
    dt = end_time/num_steps
    brownian_increments = (math.sqrt(dt) * np.random.standard_normal((num_paths, num_steps)))
    if correlation_matrix is not None:
        lower_triangular_mat = np.linalg.cholesky(correlation_matrix)
        brownian_increments = lower_triangular_mat @ brownian_increments  # induce correlation
    return brownian_increments


def generate_brownian_motion_paths(
        num_paths: int, num_steps: int, end_time: float, correlation_matrix: Optional[np.ndarray] = None
) -> np.array:
    """
    Generates Brownian Motion sample paths.
    """

    brownian_increments = generate_brownian_increments(num_paths, num_steps, end_time, correlation_matrix)
    brownian_paths = np.zeros((num_paths, num_steps+1))
    brownian_paths[:, 1:] = brownian_increments.cumsum(axis=1)
    return brownian_paths


def generate_sde_euler_paths(
        drift_function: Callable[[float, float], float],
        diffusion_function: Callable[[float, float], float],
        num_paths: int,
        num_steps: int,
        end_time: float,
        starting_value: float = 0.0,
        correlation_matrix: Optional[np.array] = None
) -> np.array:
    """
    Generates discretized solution paths to the stochastic differential equation
    dX_t = mu(t, X_t) dt + sigma(t, X_t) dW_t
    where mu and sigma are the drift and diffusion functions, respectively.
    """
    dt = end_time / num_steps
    solutions = np.zeros((num_paths, num_steps+1))
    solutions[:, 0] = starting_value
    brownian_increments = generate_brownian_increments(num_paths, num_steps, end_time, correlation_matrix)

    for step in range(num_steps):
        time = step * dt / end_time
        drift = np.array([drift_function(time, value) for value in solutions[:, step]])
        diffusion = np.array([diffusion_function(time, value) for value in solutions[:, step]])
        increments = drift * dt + diffusion * brownian_increments[:, step]
        solutions[:, step+1] = solutions[:, step] + increments

    return solutions


#------------------------------------------------------------------------------

def main():
    NUM_PATHS = 2
    NUM_STEPS = 1_000_000
    END_TIME = 5

    # plotting Geometric Brownian Motion
    NUM_PATHS = 100
    START_VAL = 0.1

    drift_fxcn, diffusion_fxcn = vasicek_model(long_term_mean=0.05, reversion_scale=2, volatility=0.1)
    correlation = 0.80
    #cor_mat = np.array([[1.0, correlation], [correlation, 1.0]])
    paths = generate_sde_euler_paths(drift_fxcn,
                                         diffusion_fxcn,
                                         num_paths=NUM_PATHS,
                                         num_steps=1_000,
                                         end_time=10,
                                         starting_value=START_VAL,
                                         correlation_matrix=None)

    plt.figure(figsize=(10, 6))
    plt.title(f'Vasicek Model Sample Paths')
    plt.plot(paths.T, color='tab:blue', linewidth=0.5, alpha=0.1)
    plt.plot(paths.mean(axis=0), color='darkblue', linestyle='--')
    plt.show()

if __name__ == '__main__':
    main()


